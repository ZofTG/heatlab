"""UTILS MODULE"""

#! IMPORTS


import os
from typing import Any, Callable

import cv2
import h5py
import numpy as np

__all__ = [
    "check_type",
    "Signal",
    "read_h5",
    "read_images",
    "read_segmentation_masks",
    "IMAGE_FORMATS",
]


#! CONSTANTS


IMAGE_FORMATS = [
    "bmp",
    "dib",
    "jpeg",
    "jpg",
    "jpe",
    "jp2",
    "png",
    "webp",
    "pbm",
    "pgm",
    "ppm",
    "pxm",
    "pnm",
    "sr",
    "ras",
    "tiff",
    "tif",
    "exr",
    "hdr",
    "pic",
]


#! FUNCTIONS


def check_type(obj: object, typ: Any):
    """ensure the object is of the provided type/s"""
    if not isinstance(obj, typ):
        raise TypeError(f"{obj} must be an instance of {typ}.")
    return True


def read_h5(file: str):
    """
    read h5 files containing thermal images and return the readed data.

    Parameters
    ----------
    file: str
        the input file.

    Returns
    -------
    images: NDArray
        a (frames, height, width) NDArray
    """
    # check the file
    ext = file.rsplit(".", 1)[-1]
    if ext != "h5" or not os.path.isfile(file):
        raise TypeError("file must be a '.h5' file.")

    # get the thermal images
    with h5py.File(file, "r") as obj:
        images = obj["samples"][:]  # type: ignore
    return images


def read_images(file: str):
    """
    read the provided file and return the corresponding 3D or 4D array.

    Parameters
    ----------
    file: str
        the directory containing images to be imported or a single file image.

    Returns
    -------
    frames: NDArray
        the image as ndarray.
    """

    def _get_array(f: str):
        ext = f.rsplit(".", maxsplit=1)[-1]
        if ext not in IMAGE_FORMATS:
            msg = f"{ext} does not comply with the available formats "
            msg += f"({IMAGE_FORMATS})."
            raise TypeError(msg)
        return cv2.cvtColor(cv2.imread(f, cv2.IMREAD_COLOR), cv2.COLOR_BGR2RGBA)

    # check the input
    check_type(file, str)

    # get the frames
    if os.path.isdir(file):
        frames = []
        for f in list(os.walk(file))[-1]:
            try:
                img = _get_array(f)
                frames += [np.expand_dims(img, 0)]
            except TypeError:
                pass
        if len(frames) == 0:
            raise TypeError("No valid images have been found.")
    elif os.path.isfile(file):
        frames = [np.expand_dims(_get_array(file), 0)]
    else:
        raise TypeError("Something wrong occurred.")

    return np.concatenate(frames)


def read_segmentation_masks(file: str):
    """
    read a ".h5" file and extract the stored data.

    Parameters
    ----------
    file: str
        the path to the ".h5" file generated by the Labeller.save_masks
        method.

    Returns
    -------
    masks: NDArray
        a 4D numpy array of dtype *bool* with shape *(frames, height, width,
        segmenter)*. Here each *segmenter* corresponds to a specific
        segmentation object.

    labels: dict
        a dict containing the labels of the segmentation masks as keys and
        their indices along the last dimension of *masks* as value.
    """
    # check the input
    check_type(file, str)
    ext = file.rsplit(".", 1)[-1]
    assert ext == "h5", "file must be a '.h5' file."

    # read the data
    with h5py.File(file, "r") as h5obj:
        objs = {}
        for i in ["masks", "labels", "indices"]:
            try:
                objs[i] = h5obj[i][:]  # type: ignore
            except Exception as exc:
                raise ValueError(f"{i} key not found in {file}.") from exc

    # return
    labels = {i: v for i, v in zip(objs["labels"], objs["indices"])}
    return objs["masks"], labels


#! CLASSES


class Signal:
    """
    class allowing to generate event signals and connect them to functions.
    """

    # ****** VARIABLES ****** #

    _connected_fun: Callable | None

    # ****** CONSTRUCTOR ****** #

    def __init__(self):
        self._connected_fun = None

    # ****** PROPERTIES ****** #

    @property
    def connected_function(self):
        """return the function connected to this signal."""
        return self._connected_fun

    # ****** METHODS ****** #

    def emit(self, *args, **kwargs):
        """emit the signal with the provided parameters."""
        if self.connected_function is None:
            return None
        elif isinstance(self.connected_function, Callable):
            return self.connected_function(*args, **kwargs)
        else:
            raise TypeError("connected_function is not callable.")

    def connect(self, fun: Callable):
        """
        connect a function/method to the actual signal

        Parameters
        ----------
        fun: FunctionType | MethodType
            the function to be connected to the signal.
        """
        check_type(fun, Callable)
        self._connected_fun = fun

    def disconnect(self):
        """disconnect the signal from the actual function."""
        self._connected_fun = None

    def is_connected(self):
        """check whether the signal is connected to a function."""
        return self.is_connected is not None
