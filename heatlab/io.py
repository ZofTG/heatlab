"""IO MODULE"""

#! IMPORTS


from os.path import exists

from cv2 import COLOR_BGR2RGBA, IMREAD_COLOR, VideoCapture, cvtColor, imread
from h5py import File as FileH5
from numpy import concatenate, expand_dims, load, squeeze

from .utils import check_type

__all__ = [
    "read_h5",
    "read_numpy",
    "read_image",
    "read_video",
    "read_files",
    "read_segmentation_masks",
    "SUPPORTED_EXTENSIONS",
]


#! FUNCTIONS


def read_h5(file: str):
    """
    read h5 files containing thermal images within the "samples" key.

    Parameters
    ----------
    file: str
        the input file.

    Returns
    -------
    images: NDArray
        a (frames, height, width) NDArray
    """
    # check the file
    check_type(file, str)
    ext = file.rsplit(".", 1)[-1]
    if ext != "h5":
        raise TypeError("file must be a '.h5' file.")

    # get the images
    with FileH5(file, "r") as obj:
        images = obj["samples"][:]  # type: ignore
    images = squeeze(images)  # type: ignore
    while images.ndim < 4:
        images = expand_dims(images, -1)

    # return
    return images


def read_numpy(file: str):
    """
    read npy/npz files containing thermal images within the "samples" key.

    Parameters
    ----------
    file: str
        the input file.

    Returns
    -------
    images: NDArray
        a (frames, height, width) NDArray
    """
    # check the file
    check_type(file, str)
    ext = file.rsplit(".", 1)[-1]
    if ext not in ["npz", "npy"]:
        raise TypeError("file must be a '.npy' or '.npz' file.")

    # get the images
    with load(file) as obj:
        images = obj["samples"]  # type: ignore
    images = squeeze(images)  # type: ignore
    while images.ndim < 4:
        images = expand_dims(images, -1)

    # return
    return images


def read_image(file: str):
    """
    read a single image from file

    Parameters
    ----------
    file : str
        the file path

    Returns
    -------
    arr: np.ndarray
        a 4D array containing the image parsed via RGBA format with the
        following shapes (1, height, width, 4)
    """
    # check the file
    check_type(file, str)
    ext = file.rsplit(".", 1)[-1]
    if ext.lower() not in IMAGE_FORMATS:
        raise TypeError(f"{ext} is an unsupported video extension.")

    # read the image
    img = cvtColor(imread(file, IMREAD_COLOR), COLOR_BGR2RGBA)
    return expand_dims(img, 0)


def read_video(file: str):
    """
    read a video from file

    Parameters
    ----------
    file : str
        the file path

    Returns
    -------
    arr: np.ndarray
        a 4D array containing the frames parsed via RGBA format with the
        following shapes (frames, height, width, 4)
    """
    # check the file
    ext = file.rsplit(".", 1)[-1]
    if ext.lower() not in VIDEO_FORMATS:
        raise TypeError(f"{ext} is an unsupported video extension.")

    # read
    cap = VideoCapture(file)
    out = []
    while cap.isOpened():
        ret, frame = cap.read()
        if ret:
            img = cvtColor(frame, COLOR_BGR2RGBA).astype(int)
            out += [expand_dims(img, 0)]
        else:
            break

    # close the file and return
    cap.release()
    return concatenate(out)


def read_files(files: str | list[str]):
    """
    read the provided file(s) and return the corresponding 4D array.

    Parameters
    ----------
    file: str | list[str]
        the directory containing images to be imported or a single file image.

    Returns
    -------
    frames: NDArray
        the image as ndarray.
    """

    # check the input
    if not isinstance(files, (list, str)):
        raise ValueError("files must be a str or a list of str.")
    if isinstance(files, str):
        files = [files]
    extensions = list(SUPPORTED_EXTENSIONS.keys())
    for file in files:
        check_type(file, str)
        if not exists(file):
            raise ValueError(f"{file} does not exists.")
        ext = file.rsplit(".", 1)[-1]
        if ext not in extensions:
            raise TypeError(f"{ext} is an unsupported file extension.")

    # read the files
    out = []
    for file in files:
        ext = file.rsplit(".", 1)[-1]
        fun = SUPPORTED_EXTENSIONS[ext]
        out += [fun(file)]

    # ensure objects have the same shape
    for obj in out:
        if not all(i == j for i, j in zip(obj.shape, out[0].shape)):
            raise ValueError("All inputs must have the same shape.")

    return concatenate(out)


def read_segmentation_masks(file: str):
    """
    read a ".h5" file and extract the stored data.

    Parameters
    ----------
    file: str
        the path to the ".h5" file generated by the Labeller.save_masks
        method.

    Returns
    -------
    masks: NDArray
        a 4D numpy array of dtype *bool* with shape *(frames, height, width,
        segmenter)*. Here each *segmenter* corresponds to a specific
        segmentation object.

    labels: dict
        a dict containing the labels of the segmentation masks as keys and
        their indices along the last dimension of *masks* as value.
    """
    # check the input
    check_type(file, str)
    ext = file.rsplit(".", 1)[-1]
    assert ext == "h5", "file must be a '.h5' file."

    # read the data
    with FileH5(file, "r") as h5obj:
        objs = {}
        for i in ["masks", "labels", "indices"]:
            try:
                objs[i] = h5obj[i][:]  # type: ignore
            except Exception as exc:
                raise ValueError from exc

    # return
    labels = {i: v for i, v in zip(objs["labels"], objs["indices"])}
    return objs["masks"], labels


#! CONSTANTS


IMAGE_FORMATS = [
    "bmp",
    "dib",
    "jpeg",
    "jpg",
    "jpe",
    "jp2",
    "png",
    "webp",
    "pbm",
    "pgm",
    "ppm",
    "pxm",
    "pnm",
    "sr",
    "ras",
    "tiff",
    "tif",
    "exr",
    "hdr",
    "pic",
]

VIDEO_FORMATS = [
    "mkv",
    "mk3d",
    "mp4",
    "m4v",
    "mov",
    ".qt",
    "asf",
    "wmv",
    "avi",
    "mxf",
    ".m2p",
    "ps",
    "ts",
    "tsv",
    "m2ts",
    "mts",
    "vob",
    "evo",
    "3gp",
    "3g2",
    "f4v",
    "flv",
    "ogv",
    "ogx",
    "webm",
    "rmvb",
    "divx",
]

SUPPORTED_EXTENSIONS = {
    "h5": read_h5,
    "npz": read_numpy,
    "npy": read_numpy,
}
for i in IMAGE_FORMATS:
    SUPPORTED_EXTENSIONS[i] = read_image
for i in VIDEO_FORMATS:
    SUPPORTED_EXTENSIONS[i] = read_video
